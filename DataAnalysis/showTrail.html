<!DOCTYPE html>
<html lang="en-NZ">
<head>
	<title>Sensibel ~ Journey browser</title>

	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.3/dist/leaflet.css" />
	<script src="http://code.jquery.com/jquery-2.2.0.min.js"></script>

	<link rel="stylesheet" href="https://code.jquery.com/mobile/1.5.0-alpha.1/jquery.mobile-1.5.0-alpha.1.min.css" />
	<script src="https://code.jquery.com/mobile/1.5.0-alpha.1/jquery.mobile-1.5.0-alpha.1.min.js"></script> <!-- FIXME: 1.5 alpha version required because 1.4.5 has a bug in popup dialogs -->

	<script src="https://cdn.rawgit.com/agschwender/jquery.formatDateTime/master/dist/jquery.formatDateTime.min.js"></script> <!-- canonical source: https://github.com/agschwender/jquery.formatDateTime/raw/master/dist/jquery.formatDateTime.min.js -->
	<script src="https://unpkg.com/leaflet@1.0.3/dist/leaflet.js"></script>
	<script src="https://cdn.rawgit.com/makinacorpus/Leaflet.GeometryUtil/master/src/leaflet.geometryutil.js"></script>
	<script src="https://cdn.rawgit.com/makinacorpus/Leaflet.AlmostOver/gh-pages/src/leaflet.almostover.js"></script>
	<script src="https://npmcdn.com/@turf/turf@3.5.1/turf.min.js"></script>
	<!-- <script src="lib/spectrum.js"></script> -->
	
	<script src="//cdn.jsdelivr.net/pouchdb/6.1.2/pouchdb.min.js"></script>

	<script src="config.js"></script>

	<!-- <link rel="stylesheet" type="text/css" href="ui/css/spectrum.css" /> -->
	<link href="https://fonts.googleapis.com/css?family=Raleway:400,uni,b,bi" rel="stylesheet" />
	<link rel="stylesheet" type="text/css" href="ui/css/basic.css" />
	<link rel="stylesheet" type="text/css" href="ui/css/resets.css" />

	<script type="text/javascript">
		var map;
		var _VERSION = '0.3.19';

		var UNKNOWN_CYCLIST = '[the unknown cyclist]';
		var UNKNOWN_TIME = '[not recorded]';

		var BUTTON_VALUE_GOOD = '01';
		var BUTTON_VALUE_BAD = '02';

		var categories = [	// FIXME: obviously not a continuing goer
			'Infrastructure',
			'Environmental',
			'Wayfinding',
			'Social',
			'Safety',
			'Near miss',
			'Traffic',
			'Bike mechanics',
			];

		var journeys = {};

		var localStore = new PouchDB(config.dataStore.database);
		var remoteStore = config.dataStore.endpoint + '/' + config.dataStore.database;

		$(document).ready(function() {

			$('h1').after('<span class="meta version">v' + _VERSION + ' (<a href="showTrail.html">latest</a>)</span>');

			if ( map === undefined ) {
				map = L.map('viz-canvas').setView([-36.85, 174.76], 13);

				var baseMaps = {
					'Dark Matter': config.layer.CartoDB_DarkMatter.tiles,
					'OSM Carto': config.layer.osm.tiles,
					'Thunderforest OpenCycleMap': config.layer.Thunderforest_OpenCycleMap.tiles,
					}
				baseMaps['Dark Matter'].addTo(map);
				L.control.layers(baseMaps).addTo(map);
			}
			// console.log(map);

			console.log('Syncing with remote datastore ..');

			var startLiveSync = function() {
				localStore.sync(remoteStore, {
					live: true,
					retry: true,
					});
				};

			localStore.sync(remoteStore).then( // one-shot wrapper because we want to report status more easily and also ..???
					function (info) {
						console.log(' .. succeeded! Setting up a live sync now');
						startLiveSync();
					}).catch(
					function (err) {
						console.log(" .. failed, we'll keep trying.");
						startLiveSync();
					}
				);

			localStore.allDocs( {
				include_docs: true,
				// startkey:  'dev-', // endkey: 'dev-',
				descending:   true,
				}).then(
					function(result) {
						console.log(result);
						$('#journeys').listview();
						result.rows.forEach( function(doc) {
							// console.log(doc.id);
							journeys[doc.id] = new JourneyRecord(doc);
							journeys[doc.id].render();
							});
						// console.log(journeys);
					}
				).then(
					function() {
						localStore.changes({
							since: 'now',
							live: true,
							include_docs: true,
							}
							).on('change',
								function(change){
									console.log('hey!');
									if (change.deleted) {
										console.log('deleted');
										journeys[change.id].remove(map);
									}
									else {
										console.log('modified/added');
										if (journeys.hasOwnProperty(change.id)) {
											console.log('update!');
											/* FIXME: a bit buggy, but close
											journeys[change.id].render(true);
											*/
										}
										else {
											console.log('new!');
											/* FIXME: a bit buggy, but close
											journeys[change.id] = new JourneyRecord(change);
											journeys[change.id].render();
											*/
										}
									}
									});
					}
				).catch(
					function(err) {
						console.log('fail getting allDocs');
						console.log(err);
					}
				);
			});

	</script>
	<script src="geo-leaflet.js" type="text/javascript"></script>
	<script src="ui.js" type="text/javascript"></script>

</head>

<body>

	<h1><img class="logo" src="ui/images/sensibel-logo-green.png" alt="Sensibel" /> Journey browser</h1>

	<div class="track-explorer" id="track-explorer">
		<div class="selector">
			<ul id="journeys">
			</ul>
		</div>
		<div id="viz-canvas" class="map"></div>
		<div class="tools">
			<!--
			<input type="file" id="file" name="file" />
			-->
			<div id="log" class="output"></div>
		</div>
	</div>

	<!-- <div id="meta" class="output"></div> -->

	<script type="text/javascript">

		function JourneyRecord(record) {
			var __this = this;

			// console.log(record.doc.type);
			this['geoJSON']    = record.doc;
			this['metadata']   = this.geoJSON.properties;

			this.render = function(refresh) {
				refresh = ( typeof refresh == 'undefined' ? false : refresh );
				console.log('refresh = ' + refresh.toString());

				// handle some missing values ..
				var rider = this.metadata.hasOwnProperty('rider') ? this.metadata.rider : UNKNOWN_CYCLIST;
				
				var duration = ( this.metadata.hasOwnProperty('started') && this.metadata.hasOwnProperty('ended')
					? function(start, finish){
						var bits = millisecondsToComponents(new Date(finish) - new Date(start));
						// FIXME: something about $().after() I don't get - jQ won't return the seconds unbolded here
						// return $('<strong/>').text(bits.hours + ':'  + bits.mins).after(':' + bits.secs);
						return bits.hours + ':'  + bits.mins + ':' + bits.secs;
						}(this.metadata.started, this.metadata.ended)
					: '[not recorded]'
					);

				var lineString = function() { // TODO: use _getLineString?
					// console.log(__this.geoJSON.features);
					if ( __this.geoJSON && ( LineStrings = __this.geoJSON.features.filter(GJUtils.isLineString) ) ) {
						return LineStrings[0]; // we'll just take the first, shouldn't be more than one
					}
					}();

				var distance = lineString.geometry.coordinates.length ? turf.lineDistance(lineString) : 0; // this is to work around an error turfjs throws when geometry.coordinates is empty, but we also should not be uploading these tracks!

				// console.log(rider + ' : ' + duration);

				var $heading = $('<h3/>')
					// .attr('title', itemReference) // this is invaluable at times if debugging based on file names
					.append($('<label/>')
						.attr('for', record.id)
						.text(rider)
						);

				var goodPoints = GJUtils.getPoints(__this.geoJSON, BUTTON_VALUE_GOOD);
				var badPoints = GJUtils.getPoints(__this.geoJSON, BUTTON_VALUE_BAD);

				var $content = $('<p/>')
					.attr('class','journey-summary')
					.append( function() {
						var $span = $('<span/>')
							.attr('class', 'meta date')
							.text( __this.metadata.hasOwnProperty('started') ? $.formatDateTime('MM dS, hh:ii', new Date(__this.metadata.started)) : UNKNOWN_TIME )
							;
						if(__this.metadata.hasOwnProperty('started')) {
							$span.attr('title', 'Journey started: ' + $.formatDateTime("DD, dS MM yy 'at' g:iia", new Date(__this.metadata.started)));
						}
						return $span;
						});

				$content.append($('<div/>')
					.attr('class', 'glance-panel')
					.append($('<img/>')
						.attr('class', 'meta avatar')
						.attr('src', function () {
							return getAvatar( __this.metadata.hasOwnProperty('rider') ? __this.metadata.rider : undefined );
							})
						.attr('alt', rider)
						// TODO: add a popup on hover with info about user
						)
					.append($('<ul/>')
						.attr('class','stats')
						.append($('<li/>')
							// .attr('id', 'metric-distance-' + itemReference)
							.attr('class', 'distance')
							.text(distance.toPrecision(2) + 'km') // TODO: make this the title text and add infographic line
							)
						.append($('<li/>')
							.attr('class', 'duration')
							.append(duration)
							)
						.append($('<li/>')
							.attr('class', 'sentiment')
							.text('+' + goodPoints.length + ' / -' + badPoints.length) 
							// TODO: make this (or similar) the title text and add infographic line
							)
						)
					// TODO - sexy stats here
					/* THIS WORKS ..
					.append($('<img/>')
						.attr('src','ui/images/stat-length.png')
						)
					*/
					);

				var $controls = $('<div/>')
					.attr('class', 'map-controls')
					.append($('<input/>')
						.attr({
							'type':  'checkbox',
							'id':    record.id,
							'class': 'journey',
							})
						.change( function() {
							if (this.checked) {
								//FIXME: neither the override idea or the enable/disable idea below work, but they don't break it :/

								var styleOverride = {};
								if (document.getElementById('color.' + record.id).value) {
									styleOverride = {'color': document.getElementById('color.' + record.id).value,}
								}
								// console.log($.extend({}, config.rendering['viz-canvas'].lineStyle, styleOverride));
								journeys[record.id].showOn(map, styleOverride);
								// document.getElementById('color.' + itemId).removeAttribute('disabled');
									/* {
										'color': $('#color.' + itemId).val(),
									} */
							}
							else {
								journeys[record.id].hideOn(map);
								// document.getElementById('color.' + itemId).setAttribute('disabled', 'disabled');
							}
							$(this).parents('#journeys li').toggleClass('showing');
							})
						)
					.append($('<input/>')
						.attr({
							'type': 'color',
							'id': 'color.' + record.id,
							'class': 'color',
							'title': 'Set Journey line colour',
							})
						// .attr('disabled', 'disabled')
						.val(config.rendering['viz-canvas'].lineStyle.color)
						/* // if I ever get a better colour popup (than the disappointing Spectrum)
						.click( function(evt) {
							evt.preventDefault();
							})
						*/
						.change( function(evt) {
							console.log(this.value);
							if (journeys[record.id].lineStringLayer) {
								journeys[record.id].lineStringLayer.setStyle({ // CHECKME: unclear from Leaflet docs, but this doesn't override any style options already set
								'color': this.value,
								});
							}
							})
						/*
						.spectrum({
							   showPalette: true,
							   showSelectionPalette: true,
							   maxSelectionSize: 8,
							   hideAfterPaletteSelect: true,
							   showInitial: true,
							   // showInput: true,
							   change: function(colour) {
												console.log(colour);
												loadedRecords[itemName].lineStringLayer.setStyle({ // CHECKME: ensure (unclear from Leaflet docs) that this doesn't override any style options already set
													'color': colour.toHexString(),
													});
												}
							})
							*/
						);

				$item = $('<li/>')
					.attr('id', 'li.' + record.id)
						.append($controls)
						.append($('<div/>')
							.attr('class', 'hoozit')
							.append($heading)
							.append($content)
							);

				// TODO: add a button/link to zoom to the track's bounds
				
				if (refresh) {
					$("#li\\." + record.id).replaceWith($item);
					if(__this.layerGroup) {
						console.log('redraw');
						__this.layerGroup.eachLayer( function(layer) {
							layer.redraw(); // FIXME: doesn't work??
							});
					}
				}
				else {
					$('#journeys').append($item);
				}
				
				$('#journeys').listview('refresh');
			}

			this.remove = function(targetMap) {
				console.log('removing');
				this.hideOn(targetMap);
				$("#li\\." + record.id).remove();
				$('#journeys').listview('refresh');
				};

			this.showOn = function(targetMap, lineStyle) {
				var featureIndex = 0;
				var initialLineStyle = Object.assign({}, config.rendering['viz-canvas'].lineStyle, lineStyle ? lineStyle : {});

				// NB order of this and subsequent L.geoJSON call is important - probably suboptimal architecture, should be refactored - be careful in the meantime!
				var lineStringsLayerGroup = L.geoJson(this.geoJSON, {
					'filter': function(feature, layer) {
						return ( feature.geometry && feature.geometry.type && feature.geometry.type == 'LineString' );
						// TODO: use GJUtils.isLineString(feature)
						},
					'onEachFeature': function(feature, layer) {
						layer.setStyle(initialLineStyle);

						__this.lineStringLayer = layer; // FIXME; should really be an array or layerGroup as we could have more than one in the real world - see http://stackoverflow.com/a/19118143

						featureIndex++;
						}
					});

				// NB order of this and previous L.geoJSON call is important - probably suboptimal architecture, should be refactored - be careful in the meantime!
				var pointsLayerGroup = L.geoJson(this.geoJSON, {
					'filter': function(feature, layer) {
						return ( feature.properties && feature.properties.measure && feature.properties.measure == 'button' );
						},
					'onEachFeature': function(feature, layer) {
						// if (feature.properties && feature.properties.measure && feature.properties.measure == 'button') {

						var pointLatitude = feature.geometry.coordinates[1];
						var pointLongitude = feature.geometry.coordinates[0];
						var hasCategory = feature.properties.hasOwnProperty('category');
						var hasComment = feature.properties.hasOwnProperty('comment');
						var hasAnnotations = hasCategory || hasComment;
						var iconUrl = ( feature.properties.value == BUTTON_VALUE_GOOD ? 'ui/images/dot-pos.png' : 'ui/images/dot-neg.png' );
						if (hasAnnotations) {
							iconUrl = iconUrl.replace('.png', '-annotated.png');
						}
						var displayMarker = L.icon( {
							'iconUrl':     iconUrl, // TODO: icon URLs from config
							'riseOnHover': true,
							});

						var popupContent = getPopupContent(feature.properties);

						// FIXME: categories not done properly here, read-only too
						var categoryOptions;
						categoryOptions += '<option></option>';
						for (var i=0; i < categories.length; i++) {
							categoryOptions += '<option value="' + categories[i] + '"';
							if ( hasCategory && (feature.properties.category == categories[i]) ) {
								categoryOptions += ' selected="selected"';
							}
							categoryOptions += '>';
							categoryOptions += categories[i];
							categoryOptions += '</option>\n';
						}
						// console.log('categoryOptions: ' + categoryOptions);

						popupContent += ' \
							<form name="annotate"> \
								<input type="hidden" name="index" value="' + featureIndex + '" /> \
								<input type="hidden" name="document" value="' + record.id + '" /> \
							<label for="category.' +  + featureIndex + '">Category:</label> \
							<select id="category.' +  + featureIndex + '" name="category"> \
							' + categoryOptions + ' \
							</select> \
							';

						var commentValue = ( hasComment ? feature.properties.comment : '');
						var placeHolder = 'What was so ' + (feature.properties.value == BUTTON_VALUE_GOOD ? 'good' : 'bad') + ' here?';
						var commentForm = '<label for="comment.' +  + featureIndex + '">Comment:</label> \
							<textarea id="comment.' + featureIndex + '" name="comment" placeholder="' + placeHolder + '">' + commentValue + '</textarea> \
							<input type="button" value="Send"  onclick="sendAnnotation(this.form);" /> \
							</form> \
							';

						popupContent += commentForm;

						layer.setIcon(displayMarker);
						layer.bindPopup(popupContent, {
							className: (feature.properties.value == BUTTON_VALUE_GOOD ? 'good' : 'bad'),
							}).on('popupopen', function(evt) {

							console.log('popup open triggered');
							
							// need to check we haven't already added the image ot the popup, or it will request a new one and add it every time
							var depictionWrapperStart = '<div class="depiction"';
							if (!evt.popup.getContent().includes(depictionWrapperStart)) {

								var depictionContent;

								// Note could just use this.getLatLng() ?? here instead of setting thes evars above - depends if they are needed elsewhere
								var metadataRequest = $.getJSON('https://maps.googleapis.com/maps/api/streetview/metadata?location=' + pointLatitude + ',' + pointLongitude + '&key=' + config.google_streetview_API_key);

								metadataRequest.done(function(json) {
									if (json.status == 'OK') {
										var heading = GJUtils.attemptBearing(feature, GJUtils.getLineString(__this.geoJSON));
										console.log('heading:'); console.log(heading);
										var pointIdentifier = 'x' + pointLatitude.toString().replace('.','-') + 'y' + pointLongitude.toString().replace('.','-');
										var previewImageURL = 'https://maps.googleapis.com/maps/api/streetview?size=200x200&location=' + pointLatitude + ',' + pointLongitude + (heading ? '&heading=' + heading : '') + '&key=' + config.google_streetview_API_key;
										// &fov=90&heading=235&pitch=10
										var identifierImage = '<img id="depiction-' + pointIdentifier + '"  class="ground-photo thumb" src="' + previewImageURL + '" />';
										// popupContent += identifierImage;
										depictionContent = '<a data-rel="popup" href="#depiction-expanded-' + pointIdentifier + '" data-transition="flip">' + identifierImage + '</a>';
										// evt.popup.setContent(evt.popup.getContent() + depictionContent);

										// console.log(map.getSize());
										var fullImage = {
											'width':  Math.round(map.getSize().x * 0.9),
											'height': Math.round(map.getSize().y * 0.9),
											};
										// FIXME - need to allow for exceeding 640px limit - maybe not, seems to just round down to 631px ??
										fullImage['URL'] =  'https://maps.googleapis.com/maps/api/streetview?size=' + fullImage.width + 'x' + fullImage.height + '&location=' + pointLatitude + ',' + pointLongitude + '&key=' + config.google_streetview_API_key;
										// &fov=90&heading=235&pitch=10

										// FIXME: close icon doesn't render
										// <a href="#" data-rel="back" data-role="button" data-icon="delete" data-iconpos="notext" class="ui-btn-right">Close</a> \
										// TODO: insert a heading with reverse geocoded position
										$('<div id="depiction-expanded-' + pointIdentifier + '" data-role="popup" data-theme="a" data-overlay-theme="a"> \
												<p> \
													<img class="ground-photo expanded" src="' + fullImage.URL + '" /> \
												</p> \
											</div> \
											').popup();
									}
									else {
										depictionContent = '<p class="notice">No imagery available here.</p>';
									}
									});

								metadataRequest.fail(function() {
									depictionContent = '<p class="notice">No image metadata</p>';
									});

								// Going to leave this here to maybe save some trouble if any of this is needed
								// It's an attempt to reposition the popup, which gets skewed after the streetview image loads
								// (this particular problem ended up being solved with CSS!)
								// var loc = this.getLatLng(); var __popup = this;
								metadataRequest.always(function() {
									console.log('JSON request promise resolved');
									// __popup.setLatLng(loc);
									// __popup.update();
									evt.popup.setContent(evt.popup.getContent() + depictionWrapperStart + '>' + depictionContent + '</div>');
									});
							}
							});

						featureIndex++;
						},
					});

				// console.log(lineStringsLayerGroup);
				this.layerGroup = pointsLayerGroup.addLayer(lineStringsLayerGroup);
				this.layerGroup.addTo(targetMap);

				if ( config.SHOW_TRACKPOINTS != 'none' ) {
					targetMap.almostOver.addLayer(lineStringsLayerGroup);

					var pointMarker = L.circleMarker( [-90,180], {
						'color': 'white',
						'weight': 5,
						'radius': 8,
						'fillOpacity': 0.2,
						'fillColor': 'white',
						})

					if ( config.SHOW_TRACKPOINTS == 'properties' ) {
						pointMarker.bindTooltip('trackpoint', {
							'opacity':0.7,
							'offset':[0,-4],
							});
					}

					targetMap.on('almost:over', function (evt) {
						targetMap.addLayer(pointMarker);
						evt.layer.setStyle({ // TODO: style from config
							'color': 'red',
							});
						});

					targetMap.on('almost:move', function (evt) {
						// TODO: simplify snap by using http://makinacorpus.github.io/Leaflet.GeometryUtil/global.html#closest
						var line = evt.layer.feature;
						var pt = turf.point([evt.latlng.lng, evt.latlng.lat]);
						var snapped = turf.pointOnLine(line, pt);
						// console.log(snapped);
						var snappedLatLng = L.latLng(snapped.geometry.coordinates[1],snapped.geometry.coordinates[0]);

						if ( config.SHOW_TRACKPOINTS == 'properties' ) {
							var tooltipText;
							if(line.properties && line.properties.coordinateProperties) {
								tooltipText = 'times';
								var coordinateProperties = coordinatePropertiesAt(snapped.geometry.coordinates, line);
								tooltipText = formatCoordinateProperties(coordinateProperties, ['lat', 'lon']);
							}
							else {
								tooltipText = 'trackpoint';
							}
							pointMarker.setTooltipContent(tooltipText);
						}

						pointMarker.setLatLng(snappedLatLng);

						});

					targetMap.on('almost:out', function (evt) {
						targetMap.removeLayer(pointMarker);
						evt.layer.setStyle(initialLineStyle);
						});

					targetMap.on('almost:click', function (evt) {
						evt.layer.setStyle({ // TODO: style from config
							'weight': 10,
							});
						evt.layer.openPopup();
						});
				}

				// console.log('lineStringLayer: '); console.log(lineStringLayer);
				this.lineStringLayer.bindPopup('<h2>Journey details</h2>\n' + formatAttributes(this.geoJSON));

				// console.log('gJLayer: '); console.log(gJLayer);
				targetMap.fitBounds(this.layerGroup.getBounds());

				// FIXME: some redundancy below here!
				var startMarker = L.icon( {
					'iconUrl': 'ui/images/dot-start.png', // TODO: icon URLs from config
					'title':   'Start',
					});
				var finishMarker = L.icon( {
					'iconUrl': 'ui/images/dot-finish.png', // TODO: icon URLs from config
					'title':   'Finish',
					});
				var started = this.lineStringLayer.getLatLngs()[0];
				var finished = this.lineStringLayer.getLatLngs().last();
				var startedProperties = {'value': 'Start',};
				var finishedProperties = {'value': 'Finish',};
				// console.log(__this.metadata.hasOwnProperty('started'));

				if (__this.metadata.hasOwnProperty('started')) {
					startedProperties['time'] = __this.metadata.started;
				}
				if (__this.metadata.hasOwnProperty('ended')) {
					finishedProperties['time'] = __this.metadata.ended;
				}

				var startedPopup = getPopupContent(startedProperties);
				var finishedPopup = getPopupContent(finishedProperties);

				this.layerGroup.addLayer(L.marker(started, { 'icon': startMarker, }).bindPopup(startedPopup)).addTo(targetMap);
				this.layerGroup.addLayer(L.marker(finished, { 'icon': finishMarker, }).bindPopup(finishedPopup)).addTo(targetMap);

			}

			this.hideOn = function(targetMap) {
				this.layerGroup && this.layerGroup.eachLayer( function(layer) {
					targetMap.removeLayer(layer);
					} );
			}

			this.update = function() {
				// TODO: some tests here to make sure there is something loaded

				localStore.get(record.id).then(
					function(doc) {
						localStore.put(Object.assign({}, __this.geoJSON, {'_rev': doc._rev})).then(
							function(result) {
								console.log('yay update!');
								console.log(result);
							}).catch(
							function(err) {
								console.log('boo update for rev' + doc._rev + ' doc ' + __this.geoJSON);
								console.log('err: ' + err.name + JSON.stringify(err));
								// TODO - a better fail
							});
						});
				};

			var getPopupContent = function(properties) {
				var displayValue = ( properties.value == BUTTON_VALUE_GOOD ? 'Sweet!' : ( properties.value == BUTTON_VALUE_BAD ? 'Stink' : properties.value ) ); // TODO: captions from config
				var formattedDate = $.formatDateTime('D MM d, yy hh:ii', new Date(properties.time.replace('Z','+12:00'))); // see also http://momentjs.com
				var markup = '<h2>' + displayValue + '</h2>\n<p>' + formattedDate + '</p>\n';

				return markup;
			}

		}

		var sendAnnotation = function(frm) {
			var fields = {};
			var $relevantFields = $(frm).find(':checkbox,input[type="text"],input[type="hidden"],:radio,:password,textarea,select');
			$relevantFields.each( function() {
				fields[$(this).attr('name')] = $(this).val();
				});

			var geoJSON = journeys[fields.document].geoJSON;
			var feature = geoJSON.features[fields.index];
			feature.properties['category'] = fields.category;
			feature.properties['comment'] = fields.comment;

			journeys[fields.document].update();

			// refresh map
			// TODO: won't need this if we trigger refreshes from document changes
			journeys[fields.document].showOn(map);

			// some feedback
			$(frm).append('<p class="success">Updated</p>');
			};

		var coordinatePropertiesAt = function(coordinates, timedLineString) {
			var result = [];
			if (timedLineString.properties && timedLineString.properties.coordinateProperties) {
				var aligned = consolidateTimestampedLineString(timedLineString);
				var matched = aligned.filter( function(item, index) {
					return ( item.lat == coordinates[1] && item.lon == coordinates[0] );
					});
				result = result.concat(matched);
			}
			return result;
			};

		var pivotCoordinateProperties = function(coordinateProperties) {
			var result = {};

			// console.log(coordinateProperties[0]);
			if (coordinateProperties && coordinateProperties.length) {
				Object.keys(coordinateProperties[0]).forEach( function(propertyName) {

					result[propertyName] = [];
					for(i=0 ; i < coordinateProperties.length ; i++) {
						// TODO - null values
						result[propertyName].push(coordinateProperties[i][propertyName]);
					}
				});
			}
			return result;
			};

		var formatCoordinateProperties = function(coordinateProperties, exclusions, labels) {
			exclusions = exclusions || [];
			var listDelimiter = ',';
			var lineDelimiter = '\n';
			var resultLines = [];
			var coordinateProperties = pivotCoordinateProperties(coordinateProperties);

			// TODO - just handling nice labels for 'times' coordinate property at present

			$.each(coordinateProperties, function(key, values) {
				if (!exclusions.includes(key)) {
					var label = key;
					values = values.filter( function(value) { // eliminate null and undefined members
						return value;
						});
					if (key == 'times' ) {
						label = 'Times';
						values = values.map( function(timestamp) {
							return $.formatDateTime("'<strong>'hh:ii'</strong>':ss", new Date(timestamp));
							});
					}
					resultLines.push( ( labels ? label + ': ' : '' ) + values.join(listDelimiter));
				}
				});

			return resultLines.join(lineDelimiter);
			};

		var consolidateTimestampedLineString = function(timedLineString) {
			var result  = [];
			if (timedLineString.properties && timedLineString.properties.coordinateProperties) { // life is like a box of chocolates ..
				for(i=0 ; i < timedLineString.geometry.coordinates.length ; i++) {
					var member = {
						'lat': timedLineString.geometry.coordinates[i][1],
						'lon': timedLineString.geometry.coordinates[i][0],
						};
					Object.keys(timedLineString.properties.coordinateProperties).forEach( function(propertyName) {
						member[propertyName] = timedLineString.properties.coordinateProperties[propertyName][i];
						});
					result.push(member);
				}
			}
			return result;
			};

		// TODO: stub that returns geneic avatars until we have a system!
		var getAvatar = function(userName) {
			if(userName) {
				// console.log('Username given: ' + userName);
				return 'http://lorempixel.com/g/32/32/cats/'; // + userName;
			}
			return 'ui/images/user.placeholder.png';
			};

	</script>

</body>
